{
  "json_schema_major_version": "1",
  "json_schema_minor_version": "2",
  "json_content_version": "1",
  "function_name": "FrequentPaths",
  "function_version": "2.2",
  "function_type": "driver",
  "function_r_name": "aa.frequent.paths",
  "short_description": "Compute frequent sequential patterns among a sequence table.",
  "long_description": "This function takes the input table and output the frequence sequential patterns according to a given threshold.",
  "input_tables": [
    {
      "name": "InputTable",
      "allowsLists": false,
      "useInR": true,
      "description": "Specifies the name of the table that contains the input sequences. Each row is one item in a sequence. If input_table does not include a schema, the function searches for it in the user\u2019s search path. The function ignores rows that contain any NULL values.",
      "isRequired": true,
      "datatype": "TABLE_ALIAS",
      "rOrderNum": 1,
      "rName": "data",
      "alternateNames": [],
      "rDescription": "Specifies the name of the table that contains the input sequences. Each row is one item in a sequence. If data does not include a schema, the function searches for it in the user\u2019s search path. The function ignores rows that contain any NULL values.",
      "requiredInputKind": [],
      "isOrdered": false,
      "partitionByOne": false
    }
  ],
  "output_tables": [
    {
      "name": "OutputTable",
      "allowsLists": false,
      "useInR": true,
      "description": "Specifies the name of the table where the function outputs the subsequences.",
      "isRequired": true,
      "datatype": "TABLE_NAME",
      "rOrderNum": 100,
      "rName": "subsequence.data",
      "alternateNames": [],
      "rDescription": "Specifies the name of the table where the function outputs the subsequences.",
      "isOutputTable": true
    },
    {
      "name": "SeqPatternTable",
      "allowsLists": false,
      "useInR": true,
      "description": "Specifies the name of the table where the function outputs sequence-pattern pairs. For example, if a sequence has a partition value of \"1\" and contains 3 patterns with IDs 2, 9, and 10, then for that sequence the function outputs the sequence-pattern pairs (\"1\", 2), (\"1\", 9), and (\"1\", 10). If sequence_pattern_table does not include a schema, the function creates it in the first schema in the user\u2019s search path. If the function finds no sequence-pattern pairs, then it does not create sequence_pattern_table.",
      "isRequired": false,
      "datatype": "TABLE_NAME",
      "rOrderNum": 101,
      "rName": "seq.pattern.table",
      "alternateNames": [
        "SequencePatternRelation"
      ],
      "rDescription": "Specifies the name of the table where the function outputs sequence-pattern pairs. For example, if a sequence has a partition value of \"1\" and contains 3 patterns with IDs 2, 9, and 10, then for that sequence the function outputs the sequence-pattern pairs (\"1\", 2), (\"1\", 9), and (\"1\", 10). If seq.pattern.table does not include a schema, the function creates it in the first schema in the user\u2019s search path. If the function finds no sequence-pattern pairs, then it does not create seq.pattern.table.",
      "isOutputTable": true
    }
  ],
  "argument_clauses": [
    {
      "name": "PartitionColumns",
      "allowsLists": true,
      "useInR": true,
      "rName": "partition.columns",
      "allowedTypes": [],
      "datatype": "COLUMN_NAMES",
      "targetTable": [
        "InputTable"
      ],
      "rOrderNum": 12,
      "checkDuplicate": true,
      "isRequired": true,
      "rDescription": "Specifies the names of the columns that comprise the partition key of the input sequences.",
      "alternateNames": [
        "PartitionColumn"
      ],
      "allowedTypeGroups": [
        "DISTRIBUTIONTYPE"
      ],
      "allowPadding": true,
      "matchLengthOfArgument": "",
      "description": "Specifies the names of the columns that comprise the partition key of the input sequences."
    },
    {
      "name": "TimeColumn",
      "allowsLists": false,
      "useInR": true,
      "rName": "time.column",
      "allowedTypes": [],
      "datatype": "COLUMN_NAMES",
      "targetTable": [
        "InputTable"
      ],
      "rOrderNum": 3,
      "checkDuplicate": true,
      "isRequired": false,
      "rDescription": "Specifies the name of the input table column that determines the order of items in a sequence. Items in the same sequence that have the same time stamp belong to the same set. *Required when item.column or item.definition is specified.",
      "requiredLength": 1,
      "alternateNames": [],
      "allowedTypeGroups": [
        "ALL"
      ],
      "allowPadding": true,
      "matchLengthOfArgument": "",
      "description": "Specifies the name of the input table column that determines the order of items in a sequence. Items in the same sequence that have the same time stamp belong to the same set. *Required when ItemColumn or ItemDefinition is specified."
    },
    {
      "name": "GroupByColumns",
      "allowsLists": true,
      "useInR": true,
      "rName": "groupby.columns",
      "allowedTypes": [],
      "datatype": "COLUMN_NAMES",
      "targetTable": [
        "InputTable"
      ],
      "rOrderNum": 5,
      "checkDuplicate": true,
      "isRequired": false,
      "rDescription": "Specifies the names of the input table columns by which to group the input table sequences. If you specify this argument, then the function operates on each group separately and copies each group_by_column to the output table.",
      "alternateNames": [],
      "allowedTypeGroups": [
        "ALL"
      ],
      "allowPadding": true,
      "matchLengthOfArgument": "",
      "description": "Specifies the names of the input table columns by which to group the input table sequences. If you specify this argument, then the function operates on each group separately and copies each group_by_column to the output table."
    },
    {
      "name": "ItemColumn",
      "allowsLists": true,
      "useInR": true,
      "rName": "item.column",
      "allowedTypes": [],
      "datatype": "COLUMN_NAMES",
      "targetTable": [
        "InputTable"
      ],
      "rOrderNum": 6,
      "checkDuplicate": true,
      "isRequired": false,
      "rDescription": "Specifies the names of the input table columns that contain the items. *Required if you specify neither ItemDefinition nor path.column.",
      "alternateNames": [],
      "allowedTypeGroups": [
        "ALL"
      ],
      "allowPadding": true,
      "matchLengthOfArgument": "",
      "description": "Specifies the names of the input table columns that contain the items. *Required if you specify neither ItemDefinition nor PathColumn."
    },
    {
      "name": "PathColumn",
      "allowsLists": false,
      "useInR": true,
      "rName": "path.column",
      "allowedTypes": [],
      "datatype": "COLUMN_NAMES",
      "targetTable": [
        "InputTable"
      ],
      "rOrderNum": 8,
      "checkDuplicate": true,
      "isRequired": false,
      "rDescription": "Specifies the name of the input table column that contains paths in the form of sequence strings. A sequence string has this syntax: '[item [, ...]]' In the sequence string syntax, you must type the outer brackets (bold). The sequence strings in this column can be generated by the nPath function. If you specify this argument, then each item set can have only one item. * Required if you specify neither item.column nor item.definition.",
      "requiredLength": 1,
      "alternateNames": [],
      "allowedTypeGroups": [
        "STRING"
      ],
      "allowPadding": true,
      "matchLengthOfArgument": "",
      "description": "Specifies the name of the input table column that contains paths in the form of sequence strings. A sequence string has this syntax: '[item [, ...]]' In the sequence string syntax, you must type the outer brackets (bold). The sequence strings in this column can be generated by the nPath function. If you specify this argument, then each item set can have only one item. * Required if you specify neither ItemColumn nor ItemDefinition."
    },
    {
      "name": "MinSupport",
      "upperBoundType": "INCLUSIVE",
      "lowerBound": 0,
      "useInR": true,
      "rName": "min.support",
      "datatype": "DOUBLE",
      "allowNaN": false,
      "rOrderNum": 2,
      "allowsLists": false,
      "upperBound": Infinity,
      "lowerBoundType": "EXCLUSIVE",
      "isRequired": true,
      "rDescription": "Determines the threshold for whether a sequential pattern is frequent. The minimum must be a positive real number. If minimum is in the range (0,1], then it is a relative threshold: If N is the total number of input sequences, then the threshold is T=N*minimum. For example, if there are 1000 sequences in the input table and minimum is 0.05, then the threshold is 50. If minimum is in the range (1,+\u221e), then it is an absolute threshold: Regardless of N,  T=minimum. For example, if minimum is 50, then the threshold is 50, regardless of N. A pattern is frequent if its support value is at least T. Because the function outputs only frequent patterns, minimum controls the number of output patterns. If minimum is small, processing time increases exponentially; therefore, Teradata recommends starting the trial with a larger value.\u2014for example, 5% of the total sequence number if you know N and 0.05 otherwise. If you specify a relative minimum and group.by.columns, then the function calculates N and T for each group. If you specify a relative minimum and path.filters, then N is the number of sequences that meet the constraints of the filters.",
      "alternateNames": [],
      "description": "Determines the threshold for whether a sequential pattern is frequent. The minimum must be a positive real number. If minimum is in the range (0,1], then it is a relative threshold: If N is the total number of input sequences, then the threshold is T=N*minimum. For example, if there are 1000 sequences in the input table and minimum is 0.05, then the threshold is 50. If minimum is in the range (1,+\u221e), then it is an absolute threshold: Regardless of N,  T=minimum. For example, if minimum is 50, then the threshold is 50, regardless of N. A pattern is frequent if its support value is at least T. Because the function outputs only frequent patterns, minimum controls the number of output patterns. If minimum is small, processing time increases exponentially; therefore, Teradata recommends starting the trial with a larger value.\u2014for example, 5% of the total sequence number if you know N and 0.05 otherwise. If you specify a relative minimum and GroupByColumns, then the function calculates N and T for each group. If you specify a relative minimum and PathFilters, then N is the number of sequences that meet the constraints of the filters."
    },
    {
      "name": "PathFilters",
      "allowsLists": true,
      "isOutputColumn": false,
      "useInR": true,
      "datatype": "STRING",
      "rOrderNum": 4,
      "rName": "path.filters",
      "isRequired": false,
      "rDescription": "Specifies the filters to use on the input table sequences. Only input table sequences that satisfy all constraints of at least one filter are input to the function. Each filter has one or more constraints, which are separated by spaces. Each constraint has this syntax: constraint (item [symbol ...]) By default, symbol is comma (,). If you specify symbol, it applies to all filters. The constraint is one of the following: STW (start-with constraint): The first item set of the sequence must contain at least one item. For example, STW(c,d) requires the first item set of the sequence to contain c or d. Sequence \u201c(a, c), e, (f, d)\u201d meets this constraint because the first item set, (a,c), contains c, EDW (end-with constraint): The last item set of the sequence must contain at least one item. For example, EDW(f,g) requires the last item set of the sequence to contain f or g. Sequence \u201c(a, b), e, (f, d)\u201d meets this constraint because the last item set, (f,d), contains f, CTN (containing constraint): The sequence must contain at least one item. For example, CTN(a,b) requires the sequence to contain a or b. The sequence \u201c(a,c), d, (e,f)\u201d meets this constraint but the sequence \u201cd, (e,f)\u201d does not. Constraints in the same filter must be different. For example, the filter 'STW(c,d) EDW(g,k) CTN(e)' is valid, but 'STW(c,d) STW(e,h)' is invalid. This argument specifies a separator and uses it in two filters: path.filters('Separator(#)', 'STW(c#d) EDW(g#k) CTN(e)', 'CTN(h#k)')",
      "alternateNames": [],
      "permittedValues": [],
      "allowPadding": true,
      "matchLengthOfArgument": "",
      "description": "Specifies the filters to use on the input table sequences. Only input table sequences that satisfy all constraints of at least one filter are input to the function. Each filter has one or more constraints, which are separated by spaces. Each constraint has this syntax: constraint (item [symbol ...]) By default, symbol is comma (,). If you specify symbol, it applies to all filters. The constraint is one of the following: STW (start-with constraint): The first item set of the sequence must contain at least one item. For example, STW(c,d) requires the first item set of the sequence to contain c or d. Sequence \u201c(a, c), e, (f, d)\u201d meets this constraint because the first item set, (a,c), contains c, EDW (end-with constraint): The last item set of the sequence must contain at least one item. For example, EDW(f,g) requires the last item set of the sequence to contain f or g. Sequence \u201c(a, b), e, (f, d)\u201d meets this constraint because the last item set, (f,d), contains f, CTN (containing constraint): The sequence must contain at least one item. For example, CTN(a,b) requires the sequence to contain a or b. The sequence \u201c(a,c), d, (e,f)\u201d meets this constraint but the sequence \u201cd, (e,f)\u201d does not. Constraints in the same filter must be different. For example, the filter 'STW(c,d) EDW(g,k) CTN(e)' is valid, but 'STW(c,d) STW(e,h)' is invalid. This argument specifies a separator and uses it in two filters: PathFilters('Separator(#)', 'STW(c#d) EDW(g#k) CTN(e)', 'CTN(h#k)')"
    },
    {
      "name": "ItemDefinition",
      "allowsLists": false,
      "isOutputColumn": false,
      "useInR": true,
      "datatype": "STRING",
      "rOrderNum": 7,
      "rName": "item.definition",
      "isRequired": false,
      "rDescription": "Specifies the name of the item definition table and the names of its index, definition, and item columns. If item_definition_table does not include a schema, the function searches for it in the schema in the user\u2019s search path. *Required if you specify neither item.column nor path.column.",
      "alternateNames": [],
      "permittedValues": [],
      "description": "Specifies the name of the item definition table and the names of its index, definition, and item columns. If item_definition_table does not include a schema, the function searches for it in the schema in the user\u2019s search path. *Required if you specify neither ItemColumn nor PathColumn."
    },
    {
      "name": "MaxLength",
      "upperBoundType": "INCLUSIVE",
      "lowerBound": 0,
      "useInR": true,
      "rName": "max.length",
      "datatype": "INTEGER",
      "defaultValue": 2147483647,
      "rOrderNum": 9,
      "allowsLists": false,
      "upperBound": 2147483647,
      "lowerBoundType": "EXCLUSIVE",
      "isRequired": false,
      "rDescription": "Specifies the maximum length of the output sequential patterns. The length of a pattern is its number of sets. By default, there is no maximum length.",
      "alternateNames": [],
      "allowNaN": false,
      "description": "Specifies the maximum length of the output sequential patterns. The length of a pattern is its number of sets. By default, there is no maximum length."
    },
    {
      "name": "MinLength",
      "upperBoundType": "INCLUSIVE",
      "lowerBound": 0,
      "useInR": true,
      "rName": "min.length",
      "datatype": "INTEGER",
      "defaultValue": 1,
      "rOrderNum": 10,
      "allowsLists": false,
      "upperBound": 2147483647,
      "lowerBoundType": "EXCLUSIVE",
      "isRequired": false,
      "rDescription": "Specifies the minimum length of the output sequential patterns. The default value is 1.",
      "alternateNames": [],
      "allowNaN": false,
      "description": "Specifies the minimum length of the output sequential patterns. The default value is 1."
    },
    {
      "name": "ClosedPattern",
      "allowsLists": false,
      "useInR": true,
      "datatype": "BOOLEAN",
      "defaultValue": false,
      "rOrderNum": 11,
      "rName": "closed.pattern",
      "isRequired": false,
      "rDescription": "Specifies whether to output only closed patterns. The default value is 'false'.",
      "alternateNames": [],
      "description": "Specifies whether to output only closed patterns. The default value is 'false'."
    }
  ]
}