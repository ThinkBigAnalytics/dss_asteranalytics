{
  "json_schema_major_version": "1",
  "json_schema_minor_version": "2",
  "json_content_version": "1",
  "function_name": "JSONParser",
  "function_version": "1.6",
  "function_type": "SQL-MR",
  "function_r_name": "aa.json.parser",
  "short_description": "Parses JSON string and produces a flattened table.",
  "long_description": "Parses JSON string and produces a flattened table. ",
  "input_tables": [
    {
      "isOrdered": false,
      "useInR": true,
      "name": "input",
      "rName": "data",
      "isRequired": true,
      "datatype": "TABLE_ALIAS",
      "rOrderNum": 1,
      "allowsLists": false,
      "partitionByOne": false,
      "rDescription": "Input table that contains JSON data",
      "requiredInputKind": [
        "PartitionByAny"
      ],
      "alternateNames": [],
      "description": "Input table that contains JSON data"
    }
  ],
  "argument_clauses": [
    {
      "name": "TextColumn",
      "allowsLists": true,
      "useInR": true,
      "rName": "text.column",
      "allowedTypes": [],
      "datatype": "COLUMNS",
      "targetTable": [
        "input"
      ],
      "rOrderNum": 2,
      "checkDuplicate": true,
      "isRequired": true,
      "rDescription": "Specifies the column name from the input table which contains the JSON string.",
      "alternateNames": [],
      "allowedTypeGroups": [
        "STRING"
      ],
      "allowPadding": true,
      "matchLengthOfArgument": "",
      "description": "Specifies the column name from the input table which contains the JSON string."
    },
    {
      "name": "Accumulate",
      "allowsLists": true,
      "useInR": true,
      "rName": "accumulate",
      "allowedTypes": [],
      "datatype": "COLUMNS",
      "targetTable": [
        "input"
      ],
      "rOrderNum": 9,
      "checkDuplicate": true,
      "isRequired": false,
      "rDescription": "Specifies the input table columns to copy to the output table.",
      "alternateNames": [],
      "allowedTypeGroups": [
        "ALL"
      ],
      "allowPadding": true,
      "matchLengthOfArgument": "",
      "description": "Specifies the input table columns to copy to the output table."
    },
    {
      "name": "Nodes",
      "allowsLists": true,
      "isOutputColumn": false,
      "useInR": true,
      "datatype": "STRING",
      "rOrderNum": 3,
      "rName": "nodes",
      "isRequired": true,
      "rDescription": "Specifies the parent/children pair. Should contain at least one parent/child pair, and all pairs specified must be in the same format. Multiple children can be specified as parent/{child1,child2,...}.",
      "alternateNames": [],
      "permittedValues": [],
      "allowPadding": true,
      "matchLengthOfArgument": "",
      "description": "Specifies the parent/children pair. Should contain at least one parent/child pair, and all pairs specified must be in the same format. Multiple children can be specified as parent/{child1,child2,...}."
    },
    {
      "name": "SearchPath",
      "allowsLists": true,
      "isOutputColumn": false,
      "useInR": true,
      "datatype": "STRING",
      "rOrderNum": 4,
      "rName": "search.path",
      "isRequired": false,
      "rDescription": "Specifies the path to find the direct value of the child. To reach the parent of the parent, include the parent of the parent in this path. When a path to the parent of the parent is supplied, all the siblings of the parent can be printed by including them in the nodes argument. If anything from root is to be parsed, then supply this argument as '/' (or leave it as an empty string).",
      "alternateNames": [],
      "permittedValues": [],
      "allowPadding": true,
      "matchLengthOfArgument": "",
      "description": "Specifies the path to find the direct value of the child. To reach the parent of the parent, include the parent of the parent in this path. When a path to the parent of the parent is supplied, all the siblings of the parent can be printed by including them in the NODES argument. If anything from root is to be parsed, then supply this argument as '/' (or leave it as an empty string)."
    },
    {
      "name": "Delimiter",
      "allowsLists": false,
      "isOutputColumn": false,
      "useInR": true,
      "datatype": "STRING",
      "defaultValue": ",",
      "rOrderNum": 5,
      "rName": "delimiter",
      "isRequired": false,
      "rDescription": "Specifies the delimiter used to separate multiple child values with the same name and which have the same parent node in the JSON String. If not defined, defaults to comma ','. Note: The delimiter cannot include '#'",
      "alternateNames": [],
      "permittedValues": [],
      "description": "Specifies the delimiter used to separate multiple child values with the same name and which have the same parent node in the JSON String. If not defined, defaults to comma ','. Note: The delimiter cannot include '#'"
    },
    {
      "name": "MaxItemNum",
      "upperBoundType": "INCLUSIVE",
      "lowerBound": 1,
      "useInR": true,
      "rName": "max.item.num",
      "datatype": "INTEGER",
      "defaultValue": 10,
      "rOrderNum": 6,
      "allowsLists": false,
      "upperBound": 2147483647,
      "lowerBoundType": "INCLUSIVE",
      "isRequired": false,
      "rDescription": "The maximum number of nodes with the same name that will be displayed in the output. The default value is 10.",
      "alternateNames": [
        "MAX_ITEM_NUMBER"
      ],
      "allowNaN": false,
      "description": "The maximum number of nodes with the same name that will be displayed in the output. The default value is 10."
    },
    {
      "name": "NodeIdOutputColumn",
      "allowsLists": false,
      "isOutputColumn": true,
      "useInR": true,
      "datatype": "STRING",
      "defaultValue": "out_nodeid",
      "rOrderNum": 7,
      "rName": "nodeid.output.column",
      "isRequired": false,
      "rDescription": " The name of the column to use in the result schema to contain the identifier (from the input table) of the each node extracted. If not defined, defaults to 'out_nodeid'.",
      "alternateNames": [
        "NODEID_OUTPUTCOLUMN_NAME"
      ],
      "permittedValues": [],
      "description": " The name of the column to use in the result schema to contain the identifier (from the input table) of the each node extracted. If not defined, defaults to 'out_nodeid'."
    },
    {
      "name": "ParentNodeOutputColumn",
      "allowsLists": false,
      "isOutputColumn": true,
      "useInR": true,
      "datatype": "STRING",
      "defaultValue": "out_parent_node",
      "rOrderNum": 8,
      "rName": "parentnode.output.column",
      "isRequired": false,
      "rDescription": "The name of column to use in the result schema to contain the tag name of the parent node extracted. If not defined, defaults to 'out_parent_node'.",
      "alternateNames": [
        "PARENTNODE_OUTPUTCOLUMN_NAME"
      ],
      "permittedValues": [],
      "description": "The name of column to use in the result schema to contain the tag name of the parent node extracted. If not defined, defaults to 'out_parent_node'."
    },
    {
      "name": "ErrorHandler",
      "allowsLists": false,
      "isOutputColumn": false,
      "useInR": true,
      "datatype": "STRING",
      "rOrderNum": 10,
      "rName": "error.handler",
      "isRequired": false,
      "rDescription": "Specifies how the function acts when it encounters a data problem. If not specified, the function aborts if the input table contains bad data (for example, invalid UTF-8 characters). ErrorHandler lets you specify an \u201cadditional\u201d column to hold any rows that were rejected as having bad data, also referred to as the output column, in the output table. The log information in the additional column lets you easily identify which input table row contains unexpected data. There are two parameters you can pass to error.handler: The first parameter tells the function whether to continue processing if bad data is encountered. 'true' means continue the processing without aborting. 'false' means abort the process when an error occurs, The second group of parameters designates the output and input columns. The parameters in this group, output_col_name: input_col_name1, input_col_name2, input_col_name3,... are optional. If you specify an output column, it will be added to the output, and bad rows are logged there. If you do not specify output_col_name, the function uses \u201cERROR_HANDLER\u201d as the name of the output column. The error output column includes the data from the input columns specified using input_col_namex, when an error occurs. The data inserted into the output column will be merged from input columns and delimited by column using a semicolon. Using error.handler('true') without specifying input columns does not add any data to the output column.",
      "alternateNames": [],
      "permittedValues": [],
      "description": "Specifies how the function acts when it encounters a data problem. If not specified, the function aborts if the input table contains bad data (for example, invalid UTF-8 characters). ErrorHandler lets you specify an \u201cadditional\u201d column to hold any rows that were rejected as having bad data, also referred to as the output column, in the output table. The log information in the additional column lets you easily identify which input table row contains unexpected data. There are two parameters you can pass to ErrorHandler: The first parameter tells the function whether to continue processing if bad data is encountered. 'true' means continue the processing without aborting. 'false' means abort the process when an error occurs, The second group of parameters designates the output and input columns. The parameters in this group, output_col_name: input_col_name1, input_col_name2, input_col_name3,... are optional. If you specify an output column, it will be added to the output, and bad rows are logged there. If you do not specify output_col_name, the function uses \u201cERROR_HANDLER\u201d as the name of the output column. The error output column includes the data from the input columns specified using input_col_namex, when an error occurs. The data inserted into the output column will be merged from input columns and delimited by column using a semicolon. Using ErrorHandler('true') without specifying input columns does not add any data to the output column."
    }
  ]
}