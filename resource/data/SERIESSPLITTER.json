{
  "json_schema_major_version": "1",
  "json_schema_minor_version": "2",
  "json_content_version": "1",
  "function_name": "SeriesSplitter",
  "function_version": "1.2",
  "function_type": "driver",
  "function_r_name": "aa.series.splitter",
  "short_description": "Splits the partitions in the input table.",
  "long_description": "SeriesSplitter splits the partitions in the input table into smaller-sized sub-partitions.",
  "input_tables": [
    {
      "name": "InputTable",
      "allowsLists": false,
      "useInR": true,
      "description": "Specifies the name of the input table to be split.",
      "isRequired": true,
      "datatype": "TABLE_ALIAS",
      "rOrderNum": 1,
      "rName": "data",
      "alternateNames": [],
      "rDescription": "Specifies the name of the input table to be split.",
      "requiredInputKind": [],
      "isOrdered": false,
      "partitionByOne": false
    }
  ],
  "output_tables": [
    {
      "name": "OutputTable",
      "allowsLists": false,
      "useInR": true,
      "isRequired": false,
      "datatype": "TABLE_NAME",
      "defaultValue": "partitioned_",
      "rOrderNum": 100,
      "rName": "output.table",
      "alternateNames": [],
      "rDescription": "Specifies the name of table that the function creates to store the data splits for all partitions. The default value is 'partitioned_input_table'. For example, if input_table is 'time_series', then output_table is 'partitioned_time_series'.",
      "isOutputTable": true,
      "description": "Specifies the name of table that the function creates to store the data splits for all partitions. The default value is 'partitioned_input_table'. For example, if input_table is 'time_series', then output_table is 'partitioned_time_series'."
    },
    {
      "name": "StatsTable",
      "allowsLists": false,
      "useInR": true,
      "isRequired": false,
      "datatype": "TABLE_NAME",
      "defaultValue": "stats_",
      "rOrderNum": 101,
      "rName": "stats.table",
      "alternateNames": [],
      "rDescription": "Specifies the name of table that the function creates to store the statistics for the splitting operation that it performs. The default value is 'stats_input_table'. For example, if data is 'time_series', then stats.table is 'stats_time_series'.",
      "isOutputTable": true,
      "description": "Specifies the name of table that the function creates to store the statistics for the splitting operation that it performs. The default value is 'stats_input_table'. For example, if input_table is 'time_series', then stats_table is 'stats_time_series'."
    }
  ],
  "argument_clauses": [
    {
      "name": "PartitionByColumns",
      "allowsLists": true,
      "useInR": true,
      "rName": "partition.columns",
      "allowedTypes": [],
      "datatype": "COLUMN_NAMES",
      "targetTable": [
        "InputTable"
      ],
      "rOrderNum": 2,
      "checkDuplicate": true,
      "isRequired": true,
      "rDescription": "Specifies the partitioning columns of input_table. These columns determine the identity of a partition. For data type restrictions of these columns, see the Aster Database Documentation.",
      "alternateNames": [],
      "allowedTypeGroups": [
        "ALL"
      ],
      "allowPadding": true,
      "matchLengthOfArgument": "",
      "description": "Specifies the partitioning columns of input_table. These columns determine the identity of a partition. For data type restrictions of these columns, see the Aster Database Documentation."
    },
    {
      "name": "OrderByColumns",
      "allowsLists": true,
      "useInR": true,
      "rName": "order.by.columns",
      "allowedTypes": [],
      "datatype": "COLUMN_NAMES",
      "targetTable": [
        "InputTable"
      ],
      "rOrderNum": 4,
      "checkDuplicate": true,
      "isRequired": false,
      "rDescription": "Specifies the ordering columns of input_table. These columns establish the order of the rows and splits. Without this argument, the function can split the rows in any order.",
      "alternateNames": [],
      "allowedTypeGroups": [
        "ALL"
      ],
      "allowPadding": true,
      "matchLengthOfArgument": "",
      "description": "Specifies the ordering columns of input_table. These columns establish the order of the rows and splits. Without this argument, the function can split the rows in any order."
    },
    {
      "name": "Accumulate",
      "allowsLists": true,
      "useInR": true,
      "rName": "accumulate",
      "allowedTypes": [],
      "datatype": "COLUMN_NAMES",
      "targetTable": [
        "InputTable"
      ],
      "rOrderNum": 7,
      "checkDuplicate": true,
      "isRequired": false,
      "rDescription": "Specifies the names of input_table columns (other than those specified by partition.columns and order.by.columns) to copy to the output table. By default, only the columns specified by partition.columns and order.by.columns are copied to the output table.",
      "alternateNames": [],
      "allowedTypeGroups": [
        "ALL"
      ],
      "allowPadding": true,
      "matchLengthOfArgument": "",
      "description": "Specifies the names of input_table columns (other than those specified by PartitionByColumns and OrderByColumns) to copy to the output table. By default, only the columns specified by PartitionByColumns and OrderByColumns are copied to the output table."
    },
    {
      "name": "SplitCount",
      "upperBoundType": "INCLUSIVE",
      "lowerBound": 1,
      "useInR": true,
      "rName": "split.count",
      "datatype": "LONG",
      "defaultValue": 4,
      "rOrderNum": 5,
      "allowsLists": false,
      "upperBound": 9223372036854775807,
      "lowerBoundType": "INCLUSIVE",
      "isRequired": false,
      "rDescription": "Note: If input_table has multiple partitions, then you cannot specify split.count. Instead, specify rows.per.split. Specifies the desired number of splits in a partition of the output table. The value of split_count must be a positive BIGINT, and its upper bound is the number of rows in the partition. The default value is 4. Base the value of split_count on the desired amount of parallelism. For example, for a cluster with 10 vworkers, make split_count a multiple of 10. If the number of rows in input_table (n) is not exactly divisible by split_count, then the function estimates the number of splits in the partition, using this formula: ceiling (n / ceiling (n / split_count) ) ",
      "alternateNames": [],
      "allowNaN": false,
      "description": "Note: If input_table has multiple partitions, then you cannot specify SplitCount. Instead, specify RowsPerSplit. Specifies the desired number of splits in a partition of the output table. The value of split_count must be a positive BIGINT, and its upper bound is the number of rows in the partition. The default value is 4. Base the value of split_count on the desired amount of parallelism. For example, for a cluster with 10 vworkers, make split_count a multiple of 10. If the number of rows in input_table (n) is not exactly divisible by split_count, then the function estimates the number of splits in the partition, using this formula: ceiling (n / ceiling (n / split_count) ) "
    },
    {
      "name": "RowsPerSplit",
      "upperBoundType": "INCLUSIVE",
      "lowerBound": 1,
      "useInR": true,
      "rName": "rows.per.split",
      "datatype": "LONG",
      "defaultValue": 1000,
      "rOrderNum": 6,
      "allowsLists": false,
      "upperBound": 9223372036854775807,
      "lowerBoundType": "INCLUSIVE",
      "isRequired": false,
      "rDescription": "Note: If input_table has multiple partitions, then specify rows.per.split instead of split.count. Specifies the desired maximum number of rows in each split in the output table. If the number of rows in input_table is not exactly divisible by rows_per_split, then the last split contains fewer than rows_per_split rows, but no row contains more than rows_per_split rows. The value of rows_per_split must be a positive BIGINT. If input_table has multiple partitions and you do not specify rows.per.split, then the function uses the value 1000.",
      "alternateNames": [],
      "allowNaN": false,
      "description": "Note: If input_table has multiple partitions, then specify RowsPerSplit instead of SplitCount. Specifies the desired maximum number of rows in each split in the output table. If the number of rows in input_table is not exactly divisible by rows_per_split, then the last split contains fewer than rows_per_split rows, but no row contains more than rows_per_split rows. The value of rows_per_split must be a positive BIGINT. If input_table has multiple partitions and you do not specify RowsPerSplit, then the function uses the value 1000."
    },
    {
      "name": "DuplicateRowsCount",
      "upperBoundType": "INCLUSIVE",
      "lowerBound": 0,
      "useInR": true,
      "rName": "duplicate.rows.count",
      "datatype": "LONG",
      "defaultValue": [
        1
      ],
      "rOrderNum": 3,
      "allowsLists": true,
      "upperBound": 1000,
      "lowerBoundType": "INCLUSIVE",
      "isRequired": false,
      "rDescription": "Specifies the number of rows to duplicate across split boundaries. By default, the function duplicates one row from the previous partition and one row from the next partition. If you specify only value1, then the function duplicates value1 rows from the previous partition and value1 rows from the next partition. If you specify both value1 and value2, then the function duplicates value1 rows from the previous partition and value2 rows from the next partition. Each argument value must be nonnegative integer less than or equal to 1000. ",
      "requiredLength": 2,
      "alternateNames": [],
      "allowPadding": true,
      "matchLengthOfArgument": "",
      "description": "Specifies the number of rows to duplicate across split boundaries. By default, the function duplicates one row from the previous partition and one row from the next partition. If you specify only value1, then the function duplicates value1 rows from the previous partition and value1 rows from the next partition. If you specify both value1 and value2, then the function duplicates value1 rows from the previous partition and value2 rows from the next partition. Each argument value must be nonnegative integer less than or equal to 1000. "
    },
    {
      "name": "SplitIdColumn",
      "allowsLists": false,
      "isOutputColumn": true,
      "useInR": true,
      "datatype": "STRING",
      "defaultValue": "split_id",
      "rOrderNum": 8,
      "rName": "split.id.column",
      "isRequired": false,
      "rDescription": "Specifies the name for the output table column that is to contain the split identifiers. The default value is 'split_id'. If the output table has another column named split_id_column, then the function returns an error. Therefore, if the output table has a column named 'split_id' (specified by accumulate, partition.columns, or Order_By_Columns), then you must use split.id.column to specify a different split_id_column.",
      "alternateNames": [],
      "permittedValues": [],
      "description": "Specifies the name for the output table column that is to contain the split identifiers. The default value is 'split_id'. If the output table has another column named split_id_column, then the function returns an error. Therefore, if the output table has a column named 'split_id' (specified by Accumulate, PartitionByColumns, or Order_By_Columns), then you must use SplitIDColumn to specify a different split_id_column."
    },
    {
      "name": "ReturnStatsTable",
      "allowsLists": false,
      "useInR": true,
      "datatype": "BOOLEAN",
      "defaultValue": true,
      "rOrderNum": 9,
      "rName": "return.stats.table",
      "isRequired": false,
      "rDescription": "Specifies whether the function returns the data in stats_table in response to the command SELECT * FROM SeriesSplitter. The default value is 'true'. When this value is 'false', the function returns only the data in output_table.",
      "alternateNames": [],
      "description": "Specifies whether the function returns the data in stats_table in response to the command SELECT * FROM SeriesSplitter. The default value is 'true'. When this value is 'false', the function returns only the data in output_table."
    },
    {
      "name": "ValuesBeforeFirst",
      "allowsLists": true,
      "isOutputColumn": false,
      "useInR": true,
      "datatype": "STRING",
      "defaultValue": [
        "-1"
      ],
      "rOrderNum": 11,
      "rName": "values.before.first",
      "isRequired": false,
      "rDescription": "If duplicate.rows.count is nonzero and order.by.columns is specified, then values.before.first specifies the values to be stored in the ordering columns that precede the first row of the first split in a partition as a result of duplicating rows across split boundaries. If values.before.first specifies only one value and order.by.columns specifies multiple ordering columns, then the specified value is stored in every ordering column. If values.before.first specifies multiple values, then it must specify a value for each ordering column. The value and the ordering column must have the same data type. For the data type VARCHAR, the values are case-insensitive. The default values for different data types are:  Numeric: -1,  CHAR(n) or VARCHAR : '-1',  Date- or time-based: 1900-01-01 0:00:00,  CHARACTER: '0',  Bit: 0,  Boolean: 'false',  IP4 : 0.0.0.0,  UUID: 0000-0000-0000-0000-0000-0000-0000-0000 ",
      "alternateNames": [],
      "permittedValues": [],
      "allowPadding": true,
      "matchLengthOfArgument": "OrderByColumns",
      "description": "If DuplicateRowsCount is nonzero and OrderByColumns is specified, then ValuesBeforeFirst specifies the values to be stored in the ordering columns that precede the first row of the first split in a partition as a result of duplicating rows across split boundaries. If ValuesBeforeFirst specifies only one value and OrderByColumns specifies multiple ordering columns, then the specified value is stored in every ordering column. If ValuesBeforeFirst specifies multiple values, then it must specify a value for each ordering column. The value and the ordering column must have the same data type. For the data type VARCHAR, the values are case-insensitive. The default values for different data types are:  Numeric: -1,  CHAR(n) or VARCHAR : '-1',  Date- or time-based: 1900-01-01 0:00:00,  CHARACTER: '0',  Bit: 0,  Boolean: 'false',  IP4 : 0.0.0.0,  UUID: 0000-0000-0000-0000-0000-0000-0000-0000 "
    },
    {
      "name": "ValuesAfterLast",
      "allowsLists": true,
      "isOutputColumn": false,
      "useInR": true,
      "datatype": "STRING",
      "defaultValue": [
        "null"
      ],
      "rOrderNum": 12,
      "rName": "values.after.last",
      "isRequired": false,
      "rDescription": "If duplicate.rows.count is nonzero and order.by.columns is specified, then values.after.last specifies the values to be stored in the ordering columns that follow the last row of the last split in a partition as a result of duplicating rows across split boundaries. If values.after.last specifies only one value and order.by.columns specifies multiple ordering columns, then the specified value is stored in every ordering column. If values.after.last specifies multiple values, then it must specify a value for each ordering column. The value and the ordering column must have the same data type.  For the data type VARCHAR, the values are case-insensitive. The default value is NULL. ",
      "alternateNames": [],
      "permittedValues": [],
      "allowPadding": true,
      "matchLengthOfArgument": "OrderByColumns",
      "description": "If DuplicateRowsCount is nonzero and OrderByColumns is specified, then ValuesAfterLast specifies the values to be stored in the ordering columns that follow the last row of the last split in a partition as a result of duplicating rows across split boundaries. If ValuesAfterLast specifies only one value and OrderByColumns specifies multiple ordering columns, then the specified value is stored in every ordering column. If ValuesAfterLast specifies multiple values, then it must specify a value for each ordering column. The value and the ordering column must have the same data type.  For the data type VARCHAR, the values are case-insensitive. The default value is NULL. "
    },
    {
      "name": "DuplicateColumn",
      "allowsLists": false,
      "isOutputColumn": true,
      "useInR": true,
      "datatype": "STRING",
      "rOrderNum": 13,
      "rName": "duplicate.column",
      "isRequired": false,
      "rDescription": "Specifies the name of the column that indicates whether a row is duplicated from the neighboring split. If the row is duplicated, this column contains 1; otherwise it contains 0.",
      "alternateNames": [],
      "permittedValues": [],
      "description": "Specifies the name of the column that indicates whether a row is duplicated from the neighboring split. If the row is duplicated, this column contains 1; otherwise it contains 0."
    },
    {
      "name": "PartialSplitId",
      "allowsLists": false,
      "useInR": true,
      "datatype": "BOOLEAN",
      "defaultValue": false,
      "rOrderNum": 14,
      "rName": "partial.split.id",
      "isRequired": false,
      "rDescription": "Specifies whether split_id_column contains only the numeric split identifier. The default value is 'false'. If the value is 'true', then split_id_column contains a numeric representation of the split identifier that is unique for each partition. To distribute the output table by split, use a combination of all partitioning columns and split_id_column. If the value is 'false', then split_id_column contains a string representation of the split that is unique across all partitions. The function generates the string representation by concatenating the partitioning columns with the order of the split inside the partition (the numeric representation). In the string representation, hyphens separate partitioning column names from each other and from the order. For example, 'pcol1- pcol2-3'. ",
      "alternateNames": [],
      "description": "Specifies whether split_id_column contains only the numeric split identifier. The default value is 'false'. If the value is 'true', then split_id_column contains a numeric representation of the split identifier that is unique for each partition. To distribute the output table by split, use a combination of all partitioning columns and split_id_column. If the value is 'false', then split_id_column contains a string representation of the split that is unique across all partitions. The function generates the string representation by concatenating the partitioning columns with the order of the split inside the partition (the numeric representation). In the string representation, hyphens separate partitioning column names from each other and from the order. For example, 'pcol1- pcol2-3'. "
    }
  ]
}